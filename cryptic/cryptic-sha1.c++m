// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

export module cryptic:sha1;
import std;
import :base64;
import :details;

export namespace cryptic {

using namespace details;

class sha1
{
public:

    using message_length_type = std::uint64_t;

    using buffer_type = std::array<std::byte,20>;

    consteval sha1() noexcept :
        m_message_length{0ull},
        m_message_digest{0x67452301u,
                         0xEFCDAB89u,
                         0x98BADCFEu,
                         0x10325476u,
                         0xC3D2E1F0u}
    {}

    sha1(auto message) noexcept : sha1()
    {
        hash(message);
    }

    __attribute__((hot))
    void hash(auto message) noexcept
    {
        reset();

        const auto bytes = details::to_bytes_span(message);

        // Handle empty message explicitly
        if (bytes.size() == 0)
        {
            finalize(std::span<const std::byte>{});
            return;
        }

        const auto total_size = bytes.size();
        
        // Optimize common case: single chunk (< 64 bytes) - avoid loop overhead
        if (total_size < chunk_size)
        {
            finalize(std::span<const std::byte>{bytes.data(), total_size});
            return;
        }

        // Multiple chunks: process full chunks first
        // Prefetch next chunk while processing current for better memory access
        const auto* __restrict data_ptr = bytes.data();
        std::size_t offset = 0;
        while (offset + chunk_size <= total_size)
        {
            // Prefetch next chunk (if available) for better memory access patterns
            if (__builtin_expect(offset + 2 * chunk_size <= total_size, 1))
            {
                __builtin_prefetch(data_ptr + offset + chunk_size, 0, 3);
            }
            update(std::span<const std::byte>{data_ptr + offset, chunk_size});
            offset += chunk_size;
        }
        
        // Finalize remaining bytes
        if (offset < total_size)
        {
            finalize(std::span<const std::byte>{data_ptr + offset, total_size - offset});
        }
    }

    void encode(std::span<std::byte,20> other) const noexcept
    {
        const auto bytes = std::as_bytes(std::span{m_message_digest});
        encode_impl(other, bytes, std::make_index_sequence<5>{});
    }

    std::string base64() const
    {
        auto buffer = buffer_type{};
        encode(buffer);
        return base64::encode(buffer);
    }

    static std::string base64(auto message)
    {
        const auto hash = sha1{message};
        return hash.base64();
    }

    std::string hexadecimal() const
    {
        constexpr const char hex_chars[] = "0123456789abcdef";
        auto result = std::string{};
        result.reserve(40); // 20 bytes * 2 hex chars per byte
        
        // Fully unroll loop for maximum performance (5 words)
        const auto word0 = m_message_digest[0];
        result.push_back(hex_chars[(word0 >> 28) bitand 0xFu]); result.push_back(hex_chars[(word0 >> 24) bitand 0xFu]);
        result.push_back(hex_chars[(word0 >> 20) bitand 0xFu]); result.push_back(hex_chars[(word0 >> 16) bitand 0xFu]);
        result.push_back(hex_chars[(word0 >> 12) bitand 0xFu]); result.push_back(hex_chars[(word0 >>  8) bitand 0xFu]);
        result.push_back(hex_chars[(word0 >>  4) bitand 0xFu]); result.push_back(hex_chars[(word0 >>  0) bitand 0xFu]);
        
        const auto word1 = m_message_digest[1];
        result.push_back(hex_chars[(word1 >> 28) bitand 0xFu]); result.push_back(hex_chars[(word1 >> 24) bitand 0xFu]);
        result.push_back(hex_chars[(word1 >> 20) bitand 0xFu]); result.push_back(hex_chars[(word1 >> 16) bitand 0xFu]);
        result.push_back(hex_chars[(word1 >> 12) bitand 0xFu]); result.push_back(hex_chars[(word1 >>  8) bitand 0xFu]);
        result.push_back(hex_chars[(word1 >>  4) bitand 0xFu]); result.push_back(hex_chars[(word1 >>  0) bitand 0xFu]);
        
        const auto word2 = m_message_digest[2];
        result.push_back(hex_chars[(word2 >> 28) bitand 0xFu]); result.push_back(hex_chars[(word2 >> 24) bitand 0xFu]);
        result.push_back(hex_chars[(word2 >> 20) bitand 0xFu]); result.push_back(hex_chars[(word2 >> 16) bitand 0xFu]);
        result.push_back(hex_chars[(word2 >> 12) bitand 0xFu]); result.push_back(hex_chars[(word2 >>  8) bitand 0xFu]);
        result.push_back(hex_chars[(word2 >>  4) bitand 0xFu]); result.push_back(hex_chars[(word2 >>  0) bitand 0xFu]);
        
        const auto word3 = m_message_digest[3];
        result.push_back(hex_chars[(word3 >> 28) bitand 0xFu]); result.push_back(hex_chars[(word3 >> 24) bitand 0xFu]);
        result.push_back(hex_chars[(word3 >> 20) bitand 0xFu]); result.push_back(hex_chars[(word3 >> 16) bitand 0xFu]);
        result.push_back(hex_chars[(word3 >> 12) bitand 0xFu]); result.push_back(hex_chars[(word3 >>  8) bitand 0xFu]);
        result.push_back(hex_chars[(word3 >>  4) bitand 0xFu]); result.push_back(hex_chars[(word3 >>  0) bitand 0xFu]);
        
        const auto word4 = m_message_digest[4];
        result.push_back(hex_chars[(word4 >> 28) bitand 0xFu]); result.push_back(hex_chars[(word4 >> 24) bitand 0xFu]);
        result.push_back(hex_chars[(word4 >> 20) bitand 0xFu]); result.push_back(hex_chars[(word4 >> 16) bitand 0xFu]);
        result.push_back(hex_chars[(word4 >> 12) bitand 0xFu]); result.push_back(hex_chars[(word4 >>  8) bitand 0xFu]);
        result.push_back(hex_chars[(word4 >>  4) bitand 0xFu]); result.push_back(hex_chars[(word4 >>  0) bitand 0xFu]);
        
        return result;
    }

    static std::string hexadecimal(auto message)
    {
        const auto hash = sha1{message};
        return hash.hexadecimal();
    }

    consteval std::size_t size() const noexcept
    {
        return 20ul;
    }

    bool operator < (const sha1& other) const noexcept
    {
    	for(auto i = 0uz; i < sizeof m_message_digest; ++i)
            if(m_message_digest[i] != other.m_message_digest[i])
                return m_message_digest[i] < other.m_message_digest[i];
        return false;
    }

    bool operator < (std::span<const std::byte, 20> other) const noexcept
    {
        const auto bytes = std::as_bytes(std::span{m_message_digest});
    	for(auto i = 0uz; i < other.size(); i += 4uz)
        {
    		if(bytes[i+3] != other[i+0]) return bytes[i+3] < other[i+0];
    		if(bytes[i+2] != other[i+1]) return bytes[i+2] < other[i+1];
    		if(bytes[i+1] != other[i+2]) return bytes[i+1] < other[i+2];
    		if(bytes[i+0] != other[i+3]) return bytes[i+0] < other[i+3];
        }
        return false;
    }

private:

    template<std::size_t... Is>
    static constexpr void encode_impl(std::span<std::byte,20> other, std::span<const std::byte> bytes, std::index_sequence<Is...>) noexcept
    {
        ((other[Is * 4 + 0] = bytes[Is * 4 + 3],
          other[Is * 4 + 1] = bytes[Is * 4 + 2],
          other[Is * 4 + 2] = bytes[Is * 4 + 1],
          other[Is * 4 + 3] = bytes[Is * 4 + 0]), ...);
    }

    static constexpr std::uint64_t chunk_size = 64u;

    __attribute__((always_inline))
    constexpr void reset() noexcept
    {
        m_message_length = 0ull;
        m_message_digest[0] = 0x67452301u;
        m_message_digest[1] = 0xEFCDAB89u;
        m_message_digest[2] = 0x98BADCFEu;
        m_message_digest[3] = 0x10325476u;
        m_message_digest[4] = 0xC3D2E1F0u;
    }

    __attribute__((hot))
    void update(std::span<const std::byte> chunk) noexcept
    {
        expects(chunk.size() == chunk_size);
        m_message_length += 8u * chunk_size; // NOTE, bits
        transform(std::span<const std::byte, chunk_size>{chunk.data(), chunk_size});
    }

    __attribute__((hot, always_inline))
    void finalize(std::span<const std::byte> last_chunk) noexcept
    {
        expects(last_chunk.size() < chunk_size);
        m_message_length += last_chunk.size() * 8u;
    
        auto block = std::array<std::byte, 64>{};
        auto pos = std::ranges::copy(last_chunk, block.begin()).out;
    
        *pos++ = std::byte{0b10000000};
    
        const auto length_pos = block.begin() + 56;
    
        if (pos > length_pos) { // no room for length â†’ need extra block
            std::fill(pos, block.end(), std::byte{0b00000000});
            transform(block);
            pos = block.begin();
        }
    
        std::fill(pos, length_pos, std::byte{0b00000000});
        encode(std::span{block}.subspan<56, 8>(), m_message_length);
        transform(block);
    }

    __attribute__((hot, always_inline))
    constexpr void transform(std::span<const std::byte,chunk_size> chunk) noexcept
    {
        // Stack allocation is fast; alignment overhead not worth it for hot path
        auto words = std::array<std::uint32_t,80>{};
        
        // Use restrict pointer for better compiler optimization
        const auto* __restrict chunk_data = chunk.data();

        // Fully unroll word loading loop for maximum performance
        // Load 4 bytes at a time with better memory access pattern
        words[ 0] = (std::to_integer<std::uint32_t>(chunk_data[ 0]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 1]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[ 2]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[ 3])      );
        words[ 1] = (std::to_integer<std::uint32_t>(chunk_data[ 4]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 5]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[ 6]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[ 7])      );
        words[ 2] = (std::to_integer<std::uint32_t>(chunk_data[ 8]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 9]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[10]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[11])      );
        words[ 3] = (std::to_integer<std::uint32_t>(chunk_data[12]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[13]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[14]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[15])      );
        words[ 4] = (std::to_integer<std::uint32_t>(chunk_data[16]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[17]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[18]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[19])      );
        words[ 5] = (std::to_integer<std::uint32_t>(chunk_data[20]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[21]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[22]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[23])      );
        words[ 6] = (std::to_integer<std::uint32_t>(chunk_data[24]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[25]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[26]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[27])      );
        words[ 7] = (std::to_integer<std::uint32_t>(chunk_data[28]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[29]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[30]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[31])      );
        words[ 8] = (std::to_integer<std::uint32_t>(chunk_data[32]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[33]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[34]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[35])      );
        words[ 9] = (std::to_integer<std::uint32_t>(chunk_data[36]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[37]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[38]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[39])      );
        words[10] = (std::to_integer<std::uint32_t>(chunk_data[40]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[41]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[42]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[43])      );
        words[11] = (std::to_integer<std::uint32_t>(chunk_data[44]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[45]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[46]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[47])      );
        words[12] = (std::to_integer<std::uint32_t>(chunk_data[48]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[49]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[50]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[51])      );
        words[13] = (std::to_integer<std::uint32_t>(chunk_data[52]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[53]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[54]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[55])      );
        words[14] = (std::to_integer<std::uint32_t>(chunk_data[56]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[57]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[58]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[59])      );
        words[15] = (std::to_integer<std::uint32_t>(chunk_data[60]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[61]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[62]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[63])      );

        // Unroll word expansion loops 4x for better performance
        for(auto i = 16uz; i < 32uz; i += 4uz)
        {
            words[i+0] = std::rotl(words[i+0-3] xor words[i+0-8] xor words[i+0-14] xor words[i+0-16], 1);
            words[i+1] = std::rotl(words[i+1-3] xor words[i+1-8] xor words[i+1-14] xor words[i+1-16], 1);
            words[i+2] = std::rotl(words[i+2-3] xor words[i+2-8] xor words[i+2-14] xor words[i+2-16], 1);
            words[i+3] = std::rotl(words[i+3-3] xor words[i+3-8] xor words[i+3-14] xor words[i+3-16], 1);
        }

        for(auto i = 32uz; i < 80uz; i += 4uz)
        {
            words[i+0] = std::rotl(words[i+0-6] xor words[i+0-16] xor words[i+0-28] xor words[i+0-32], 2);
            words[i+1] = std::rotl(words[i+1-6] xor words[i+1-16] xor words[i+1-28] xor words[i+1-32], 2);
            words[i+2] = std::rotl(words[i+2-6] xor words[i+2-16] xor words[i+2-28] xor words[i+2-32], 2);
            words[i+3] = std::rotl(words[i+3-6] xor words[i+3-16] xor words[i+3-28] xor words[i+3-32], 2);
        }

        auto a = m_message_digest[0],
             b = m_message_digest[1],
             c = m_message_digest[2],
             d = m_message_digest[3],
             e = m_message_digest[4],
             f = 0u,
             k = 0u;

        // Unroll compression loop 4x5 for better performance
        k = 0x5A827999u;
        for(auto i = 0uz; i < 20uz; i += 4uz)
        {
            f = (b bitand c) bitor ((compl b) bitand d);
            auto temp = std::rotl(a,5) + f + e + k + words[i + 0];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor ((compl b) bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 1];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor ((compl b) bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 2];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor ((compl b) bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 3];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
        }

        // Unroll compression loop 4x5 for better performance
        k = 0x6ED9EBA1u;
        for(auto i = 20uz; i < 40uz; i += 4uz)
        {
            f = b xor c xor d;
            auto temp = std::rotl(a,5) + f + e + k + words[i + 0];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 1];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 2];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 3];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
        }

        // Unroll compression loop 4x5 for better performance
        k = 0x8F1BBCDCu;
        for(auto i = 40uz; i < 60uz; i += 4uz)
        {
            f = (b bitand c) bitor (b bitand d) bitor (c bitand d);
            auto temp = std::rotl(a,5) + f + e + k + words[i + 0];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor (b bitand d) bitor (c bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 1];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor (b bitand d) bitor (c bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 2];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = (b bitand c) bitor (b bitand d) bitor (c bitand d);
            temp = std::rotl(a,5) + f + e + k + words[i + 3];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
        }

        // Unroll compression loop 4x5 for better performance
        k = 0xCA62C1D6u;
        for(auto i = 60uz; i < 80uz; i += 4uz)
        {
            f = b xor c xor d;
            auto temp = std::rotl(a,5) + f + e + k + words[i + 0];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 1];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 2];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
            
            f = b xor c xor d;
            temp = std::rotl(a,5) + f + e + k + words[i + 3];
            e = d; d = c; c = std::rotl(b,30); b = a; a = temp;
        }

        m_message_digest[0] += a;
        m_message_digest[1] += b;
        m_message_digest[2] += c;
        m_message_digest[3] += d;
        m_message_digest[4] += e;
    }

    static constexpr void encode(std::span<std::byte,8> output, const message_length_type length) noexcept
    {
    	output[7] = static_cast<std::byte>(length >>  0);
    	output[6] = static_cast<std::byte>(length >>  8);
    	output[5] = static_cast<std::byte>(length >> 16);
    	output[4] = static_cast<std::byte>(length >> 24);
    	output[3] = static_cast<std::byte>(length >> 32);
    	output[2] = static_cast<std::byte>(length >> 40);
    	output[1] = static_cast<std::byte>(length >> 48);
    	output[0] = static_cast<std::byte>(length >> 56);
    }

    message_length_type m_message_length;

    std::array<std::uint32_t,5> m_message_digest;
};

} // namespace cryptic

