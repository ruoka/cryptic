// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

export module cryptic:sha2;
import std;
import :base64;
import :details;

export namespace cryptic {

using namespace details;

template<std::uint32_t H0, std::uint32_t H1, std::uint32_t H2, std::uint32_t H3, std::uint32_t H4, std::uint32_t H5, std::uint32_t H6, std::uint32_t H7, std::size_t N>
class sha2
{
public:

    using message_length_type = std::uint64_t;

    using buffer_type = std::array<std::byte, 4 * N>;

    consteval sha2() noexcept :
        m_message_length{0ull},
        m_message_digest{H0,H1,H2,H3,H4,H5,H6,H7}
    {}

    sha2(auto message) noexcept : sha2()
    {
        hash(message);
    }

    sha2(const sha2&) = default;

    sha2(sha2&&) = default;

    __attribute__((hot))
    void hash(auto message) noexcept
    {
        reset();

        const auto bytes = details::to_bytes_span(message);

        // Handle empty message explicitly
        if (bytes.size() == 0)
        {
            finalize(std::span<const std::byte>{});
            return;
        }

        const auto total_size = bytes.size();
        
        // Optimize common case: single chunk (< 64 bytes) - avoid loop overhead
        if (total_size < chunk_size)
        {
            finalize(std::span<const std::byte>{bytes.data(), total_size});
            return;
        }

        // Multiple chunks: process full chunks first
        // Prefetch next chunk while processing current for better memory access
        const auto* __restrict data_ptr = bytes.data();
        std::size_t offset = 0;
        while (offset + chunk_size <= total_size)
        {
            // Prefetch next chunk (if available) for better memory access patterns
            if (__builtin_expect(offset + 2 * chunk_size <= total_size, 1))
            {
                __builtin_prefetch(data_ptr + offset + chunk_size, 0, 3);
            }
            update(std::span<const std::byte>{data_ptr + offset, chunk_size});
            offset += chunk_size;
        }
        
        // Finalize remaining bytes
        if (offset < total_size)
        {
            finalize(std::span<const std::byte>{bytes.data() + offset, total_size - offset});
        }
    }

    void encode(std::span<std::byte, 4 * N> other) const noexcept
    {
        const auto bytes = std::as_bytes(std::span{m_message_digest});
        encode_impl(other, bytes, std::make_index_sequence<N>{});
    }

    std::string base64() const
    {
        auto buffer = buffer_type{};
        encode(buffer);
        return base64::encode(buffer);
    }

    static std::string base64(auto message)
    {
        const auto hash = sha2{message};
        return hash.base64();
    }

    std::string hexadecimal() const
    {
        constexpr const char hex_chars[] = "0123456789abcdef";
        auto result = std::string{};
        result.reserve(8 * N); // 4 bytes per word * 2 hex chars per byte
        hexadecimal_impl(result, std::make_index_sequence<N>{});
        return result;
    }

    static std::string hexadecimal(auto message)
    {
        const auto hash = sha2{message};
        return hash.hexadecimal();
    }

    consteval std::size_t size() const noexcept
    {
        return 4 * N;
    }

    bool operator < (const sha2& other) const noexcept
    {
    	for(auto i = 0uz; i < N; ++i)
            if(m_message_digest[i] != other.m_message_digest[i])
                return m_message_digest[i] < other.m_message_digest[i];
        return false;
    }

    bool operator < (std::span<const std::byte, 4 * N> other) const noexcept
    {
        const auto bytes = std::as_bytes(std::span{m_message_digest});
    	for(auto i = 0uz; i < other.size(); i += 4uz)
        {
    		if(bytes[i+3] != other[i+0]) return bytes[i+3] < other[i+0];
    		if(bytes[i+2] != other[i+1]) return bytes[i+2] < other[i+1];
    		if(bytes[i+1] != other[i+2]) return bytes[i+1] < other[i+2];
    		if(bytes[i+0] != other[i+3]) return bytes[i+0] < other[i+3];
        }
        return false;
    }

private:

    template<std::size_t... Is>
    static constexpr void encode_impl(std::span<std::byte, 4 * N> other, std::span<const std::byte> bytes, std::index_sequence<Is...>) noexcept
    {
        ((other[Is * 4 + 0] = bytes[Is * 4 + 3],
          other[Is * 4 + 1] = bytes[Is * 4 + 2],
          other[Is * 4 + 2] = bytes[Is * 4 + 1],
          other[Is * 4 + 3] = bytes[Is * 4 + 0]), ...);
    }

    template<std::size_t... Is>
    void hexadecimal_impl(std::string& result, std::index_sequence<Is...>) const
    {
        constexpr const char hex_chars[] = "0123456789abcdef";
        ((void)([&]() {
            const auto word = m_message_digest[Is];
            result.push_back(hex_chars[(word >> 28) bitand 0xFu]);
            result.push_back(hex_chars[(word >> 24) bitand 0xFu]);
            result.push_back(hex_chars[(word >> 20) bitand 0xFu]);
            result.push_back(hex_chars[(word >> 16) bitand 0xFu]);
            result.push_back(hex_chars[(word >> 12) bitand 0xFu]);
            result.push_back(hex_chars[(word >>  8) bitand 0xFu]);
            result.push_back(hex_chars[(word >>  4) bitand 0xFu]);
            result.push_back(hex_chars[(word >>  0) bitand 0xFu]);
        }()), ...);
    }

    static constexpr std::uint64_t chunk_size = 64u;

    __attribute__((always_inline))
    constexpr void reset() noexcept
    {
        m_message_length = 0ull;
        m_message_digest[0] = H0;
        m_message_digest[1] = H1;
        m_message_digest[2] = H2;
        m_message_digest[3] = H3;
        m_message_digest[4] = H4;
        m_message_digest[5] = H5;
        m_message_digest[6] = H6;
        m_message_digest[7] = H7;
    }

    __attribute__((hot))
    void update(std::span<const std::byte> chunk) noexcept
    {
        expects(chunk.size() == chunk_size);
        m_message_length += 8u * chunk_size; // NOTE, bits
        transform(std::span<const std::byte, chunk_size>{chunk.data(), chunk_size});
    }

    __attribute__((hot, always_inline))
    void finalize(std::span<const std::byte> last_chunk) noexcept
    {
        expects(last_chunk.size() < chunk_size);
        m_message_length += last_chunk.size() * 8u;
    
        auto block = std::array<std::byte, 64>{};
        auto pos = std::ranges::copy(last_chunk, block.begin()).out;
    
        *pos++ = std::byte{0b10000000};
    
        const auto length_pos = block.data() + 56;
    
        if (pos > length_pos) { // no room for length â†’ need extra block
            std::ranges::fill(pos, block.end(), std::byte{0b00000000});
            transform(block);
            pos = block.data();
        }
    
        std::ranges::fill(pos, length_pos, std::byte{0b00000000});
        encode(std::span{block}.subspan<56, 8>(), m_message_length);
        transform(block);
    }

    __attribute__((hot, always_inline))
    constexpr void transform(std::span<const std::byte,chunk_size> chunk) noexcept
    {
        // Align words array for better cache performance
        alignas(32) auto words = std::array<std::uint32_t,64>{};
        
        // Use restrict pointer for better compiler optimization
        const auto* __restrict chunk_data = chunk.data();

        // Fully unroll word loading loop for maximum performance
        // Load 4 bytes at a time with better memory access pattern
        words[ 0] = (std::to_integer<std::uint32_t>(chunk_data[ 0]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 1]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[ 2]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[ 3])      );
        words[ 1] = (std::to_integer<std::uint32_t>(chunk_data[ 4]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 5]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[ 6]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[ 7])      );
        words[ 2] = (std::to_integer<std::uint32_t>(chunk_data[ 8]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[ 9]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[10]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[11])      );
        words[ 3] = (std::to_integer<std::uint32_t>(chunk_data[12]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[13]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[14]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[15])      );
        words[ 4] = (std::to_integer<std::uint32_t>(chunk_data[16]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[17]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[18]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[19])      );
        words[ 5] = (std::to_integer<std::uint32_t>(chunk_data[20]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[21]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[22]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[23])      );
        words[ 6] = (std::to_integer<std::uint32_t>(chunk_data[24]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[25]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[26]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[27])      );
        words[ 7] = (std::to_integer<std::uint32_t>(chunk_data[28]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[29]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[30]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[31])      );
        words[ 8] = (std::to_integer<std::uint32_t>(chunk_data[32]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[33]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[34]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[35])      );
        words[ 9] = (std::to_integer<std::uint32_t>(chunk_data[36]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[37]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[38]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[39])      );
        words[10] = (std::to_integer<std::uint32_t>(chunk_data[40]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[41]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[42]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[43])      );
        words[11] = (std::to_integer<std::uint32_t>(chunk_data[44]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[45]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[46]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[47])      );
        words[12] = (std::to_integer<std::uint32_t>(chunk_data[48]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[49]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[50]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[51])      );
        words[13] = (std::to_integer<std::uint32_t>(chunk_data[52]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[53]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[54]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[55])      );
        words[14] = (std::to_integer<std::uint32_t>(chunk_data[56]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[57]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[58]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[59])      );
        words[15] = (std::to_integer<std::uint32_t>(chunk_data[60]) << 24) bitor (std::to_integer<std::uint32_t>(chunk_data[61]) << 16) bitor (std::to_integer<std::uint32_t>(chunk_data[62]) <<  8) bitor (std::to_integer<std::uint32_t>(chunk_data[63])      );

        // Unroll word expansion loop 8x for better performance
        for(auto i = 16uz; i < 64uz; i += 8uz)
        {
            const auto s0_0 = std::rotr(words[i-15], 7) xor std::rotr(words[i-15], 18) xor (words[i-15] >> 3);
            const auto s1_0 = std::rotr(words[i-2], 17) xor std::rotr(words[i-2], 19) xor (words[i-2] >> 10);
            words[i] = words[i-16] + s0_0 + words[i-7] + s1_0;
            
            const auto s0_1 = std::rotr(words[i+1-15], 7) xor std::rotr(words[i+1-15], 18) xor (words[i+1-15] >> 3);
            const auto s1_1 = std::rotr(words[i+1-2], 17) xor std::rotr(words[i+1-2], 19) xor (words[i+1-2] >> 10);
            words[i+1] = words[i+1-16] + s0_1 + words[i+1-7] + s1_1;
            
            const auto s0_2 = std::rotr(words[i+2-15], 7) xor std::rotr(words[i+2-15], 18) xor (words[i+2-15] >> 3);
            const auto s1_2 = std::rotr(words[i+2-2], 17) xor std::rotr(words[i+2-2], 19) xor (words[i+2-2] >> 10);
            words[i+2] = words[i+2-16] + s0_2 + words[i+2-7] + s1_2;
            
            const auto s0_3 = std::rotr(words[i+3-15], 7) xor std::rotr(words[i+3-15], 18) xor (words[i+3-15] >> 3);
            const auto s1_3 = std::rotr(words[i+3-2], 17) xor std::rotr(words[i+3-2], 19) xor (words[i+3-2] >> 10);
            words[i+3] = words[i+3-16] + s0_3 + words[i+3-7] + s1_3;
            
            const auto s0_4 = std::rotr(words[i+4-15], 7) xor std::rotr(words[i+4-15], 18) xor (words[i+4-15] >> 3);
            const auto s1_4 = std::rotr(words[i+4-2], 17) xor std::rotr(words[i+4-2], 19) xor (words[i+4-2] >> 10);
            words[i+4] = words[i+4-16] + s0_4 + words[i+4-7] + s1_4;
            
            const auto s0_5 = std::rotr(words[i+5-15], 7) xor std::rotr(words[i+5-15], 18) xor (words[i+5-15] >> 3);
            const auto s1_5 = std::rotr(words[i+5-2], 17) xor std::rotr(words[i+5-2], 19) xor (words[i+5-2] >> 10);
            words[i+5] = words[i+5-16] + s0_5 + words[i+5-7] + s1_5;
            
            const auto s0_6 = std::rotr(words[i+6-15], 7) xor std::rotr(words[i+6-15], 18) xor (words[i+6-15] >> 3);
            const auto s1_6 = std::rotr(words[i+6-2], 17) xor std::rotr(words[i+6-2], 19) xor (words[i+6-2] >> 10);
            words[i+6] = words[i+6-16] + s0_6 + words[i+6-7] + s1_6;
            
            const auto s0_7 = std::rotr(words[i+7-15], 7) xor std::rotr(words[i+7-15], 18) xor (words[i+7-15] >> 3);
            const auto s1_7 = std::rotr(words[i+7-2], 17) xor std::rotr(words[i+7-2], 19) xor (words[i+7-2] >> 10);
            words[i+7] = words[i+7-16] + s0_7 + words[i+7-7] + s1_7;
        }

        auto a = m_message_digest[0],
             b = m_message_digest[1],
             c = m_message_digest[2],
             d = m_message_digest[3],
             e = m_message_digest[4],
             f = m_message_digest[5],
             g = m_message_digest[6],
             h = m_message_digest[7];

        // Unroll compression loop 8x for better performance
        for(auto i = 0uz; i < 64uz; i += 8uz)
        {
            auto S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            auto ch = (e bitand f) xor ((compl e) bitand g);
            auto temp1 = h + S1 + ch + k[i + 0] + words[i + 0];
            auto S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            auto maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            auto temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 1] + words[i + 1];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 2] + words[i + 2];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 3] + words[i + 3];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 4] + words[i + 4];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 5] + words[i + 5];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 6] + words[i + 6];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
            
            S1 = std::rotr(e,6) xor std::rotr(e,11) xor std::rotr(e,25);
            ch = (e bitand f) xor ((compl e) bitand g);
            temp1 = h + S1 + ch + k[i + 7] + words[i + 7];
            S0 = std::rotr(a,2) xor std::rotr(a,13) xor std::rotr(a,22);
            maj = (a bitand b) xor (a bitand c) xor (b bitand c);
            temp2 = S0 + maj;
            h = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
        }

        m_message_digest[0] += a;
        m_message_digest[1] += b;
        m_message_digest[2] += c;
        m_message_digest[3] += d;
        m_message_digest[4] += e;
        m_message_digest[5] += f;
        m_message_digest[6] += g;
        m_message_digest[7] += h;
    }

    static constexpr void encode(std::span<std::byte,8> output, const message_length_type length) noexcept
    {
    	output[7] = static_cast<std::byte>(length >>  0);
    	output[6] = static_cast<std::byte>(length >>  8);
    	output[5] = static_cast<std::byte>(length >> 16);
    	output[4] = static_cast<std::byte>(length >> 24);
    	output[3] = static_cast<std::byte>(length >> 32);
    	output[2] = static_cast<std::byte>(length >> 40);
    	output[1] = static_cast<std::byte>(length >> 48);
    	output[0] = static_cast<std::byte>(length >> 56);
    }

    static constexpr std::array<std::uint32_t,64> k =
    {
        0x428a2f98u, 0x71374491u, 0xb5c0fbcfu, 0xe9b5dba5u, 0x3956c25bu, 0x59f111f1u, 0x923f82a4u, 0xab1c5ed5u,
        0xd807aa98u, 0x12835b01u, 0x243185beu, 0x550c7dc3u, 0x72be5d74u, 0x80deb1feu, 0x9bdc06a7u, 0xc19bf174u,
        0xe49b69c1u, 0xefbe4786u, 0x0fc19dc6u, 0x240ca1ccu, 0x2de92c6fu, 0x4a7484aau, 0x5cb0a9dcu, 0x76f988dau,
        0x983e5152u, 0xa831c66du, 0xb00327c8u, 0xbf597fc7u, 0xc6e00bf3u, 0xd5a79147u, 0x06ca6351u, 0x14292967u,
        0x27b70a85u, 0x2e1b2138u, 0x4d2c6dfcu, 0x53380d13u, 0x650a7354u, 0x766a0abbu, 0x81c2c92eu, 0x92722c85u,
        0xa2bfe8a1u, 0xa81a664bu, 0xc24b8b70u, 0xc76c51a3u, 0xd192e819u, 0xd6990624u, 0xf40e3585u, 0x106aa070u,
        0x19a4c116u, 0x1e376c08u, 0x2748774cu, 0x34b0bcb5u, 0x391c0cb3u, 0x4ed8aa4au, 0x5b9cca4fu, 0x682e6ff3u,
        0x748f82eeu, 0x78a5636fu, 0x84c87814u, 0x8cc70208u, 0x90befffau, 0xa4506cebu, 0xbef9a3f7u, 0xc67178f2u
    };

    message_length_type m_message_length;

    std::array<std::uint32_t,8> m_message_digest;
};

using sha224 = sha2<0xc1059ed8u,0x367cd507u,0x3070dd17u,0xf70e5939u,0xffc00b31u,0x68581511u,0x64f98fa7u,0xbefa4fa4u,7>;

using sha256 = sha2<0x6a09e667u,0xbb67ae85u,0x3c6ef372u,0xa54ff53au,0x510e527fu,0x9b05688cu,0x1f83d9abu,0x5be0cd19u,8>;

} // namespace cryptic

